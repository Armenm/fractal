//
//  ReloadableSection.swift
//  SectionSystem
//
//  Created by anthony on 08/04/2019.
//  Copyright Â© 2019 Mercari. All rights reserved.
//

import Foundation
import DesignSystem

/// A section takes a dynamic list of items that refreshes upon every reload.
///
/// Item is the data source used to configure View
///
/// Do not use this class directly. This class encapsulates the reload logic only.
/// Subclasses should provide implementation for the remaining methods.
public class ReloadableSection<Item, View: UIView>: ViewSection {

    /// - Parameter itemsProvider: a closure that provides a list of items. It should return the result quickly and not do any heavy computations
    /// because it is executed on every reload.
    public init(with itemsProvider: @escaping() -> [Item]) {
        self.provideItems = itemsProvider
        self.staticItems = itemsProvider()
    }

    /// Items generated by itemsProvider, refreshed on reload.
    public private(set) var staticItems: [Item]

    /// Generate updated items
    public func willReload() {
        staticItems = provideItems()
    }

    /// Default implementation for reuseIdentifier. Override if not all items use the same identifier.
    public var reuseIdentifier: String {
        return String(describing: View.self)
    }

    public var itemCount: Int {
        return staticItems.count
    }

    public func didSelect(_ view: UIView, at index: Int) {}

    /// Subclass to provide View
    public func newView() -> View {
        Assert("subclasses need to override this function")
        return View()
    }

    /// Subclass to configure View with Item
    public func configure(_ view: View, with item: Item) {
        Assert("subclasses need to override this function")
    }

    /// Subclass to configure Size with Item
    public func size(in view: UIView, with item: Item) -> SectionCellSize {
        return .automatic
    }

    // Satisfies protocol requirement but delegates implementation to subclass
    final public func createView() -> UIView {
        return newView()
    }

    // Satisfies protocol requirement but delegates implementation to subclass
    final public func configure(_ view: UIView, at index: Int) {
        guard let view = view as? View else {
            Assert("wrong type of UIView")
            return
        }

        configure(view, with: staticItems[index])
    }

    // Satisfies protocol requirement but delegates implementation to subclass
    final public func size(in view: UIView, at index: Int) -> SectionCellSize {
        return size(in: view, with: staticItems[index])
    }

    private let provideItems: () -> [Item]
}
